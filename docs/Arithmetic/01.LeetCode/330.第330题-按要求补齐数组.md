---
title: 第330题-按要求补齐数组
date: 2020-12-29 22:45:16
permalink: /pages/7e93a4/
categories:
  - LeetCode
tags:
  - 算法
  - 贪心法
---

### [题目描述](https://leetcode-cn.com/problems/patching-array/)

给定一个已排序的正整数数组 _nums_，和一个正整数  n 。从  <font style="background: #eee; color: #666;">[1, n]</font>  区间内选取任意个数字补充到  *nums*  中，使得  <font style="background: #eee; color: #666;">[1, n]</font>  区间内的任何数字都可以用  *nums*  中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

**示例 1:**

```
输入: nums = [1,3], n = 6
输出: 1
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
```

<!-- more -->

**示例 2:**

```
输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2, 4]。
```

**示例 3:**

```
输入: nums = [1,2,2], n = 5
输出: 0
```

## 贪心法

### 思路

- 可以这么理解，以[1,5,10]的例子为例: 我们从 1 开始遍历,并且维护一个指向 nums 的下标.一开始是 1，而我们看到当前 nums 数组的第一个元素就是 1,所以不需要其他操作.直接跳到 2，并且让 pos 指向 nums 的第二个元素；

- 现在,我们的目标数是 2,但是当前 pos 指向的数却是 5,显然我们只能自己填充一个 2,所以让 res+1;既然我们已经填过 2 了,而在 2 之前可以被覆盖的最长区间长度是 1,所以当前可以遍历到的最大区间长度变成了 3(即 2 + 1);

- 然后,我们可以忽略 3,直接跳到 4(因为上一步已经知道 3 在最大覆盖范围内了)。我们发现 4 同样比当前 pos 所指向的 nums 元素小,所以我们得填入 4，即让 res + 1 既然已经填入 4 了,而我们知道在 4 之前可以覆盖的连续区间是(1 - 3),所以当前可以覆盖的最大区间被扩展到了 7(即 4 + 3);

- 接下来我们可以直接跳过 5、6、7 来到 8,而当前 pos 所指向的元素是 5,所以当前可覆盖的区间大小又可以加上 5 了(7+5 = 12),并让 pos 指向下一个元素;

- 最后我们跳过了 7 - 12，从 13 开始遍历，这时候 pos 所指的元素是 10,所以覆盖范围变成了 12 + 10 = 22 > 20，说明可以完全覆盖指定区间了！

- 到这里大概能够看出端倪 ：我们不断维持一个从 1 开始的可以被完全覆盖的区间,举个例子,当前可以完全覆盖区间是[1, k]，而当前 pos 所指向的 nums 中的元素为 B,说明在 B 之前(因为是升序，所以都比 B 小)的所有元素之和可以映射到 1-----k，而当我们把 B 也加入进去后，显然，可映射范围一定向右扩展了 B 个，也就是变成了 1---k+B，这就是解题的思路。

::: warning 思路出处
author: [Alfeim](https://leetcode-cn.com/problems/patching-array/comments/118490)
:::

### 代码

```JavaScript
/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number}
 */
const minPatches = (nums, n) => {
  // 当前可覆盖区间大小
  let currRange = 0
  // 计次数
  let count = 0

  for (let i = 1, position = 0; i <= n; ) {
    // i 初始值就是 1 ，从 1 开始和 nums 第一个 nums[position] 值比较大小
    // 如果小 或者 nums 为空，就 区间 ➕ i 扩大，计数 ➕ 1
    if (position >= nums.length || i < nums[position]) {
      count++
      currRange += i
    } else {
      // 否则区间 ➕ 当前值跳过
      currRange += nums[position]
      position++
    }

    i = currRange + 1
  }

  return count
}
```
